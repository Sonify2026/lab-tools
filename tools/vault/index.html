<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç¦»çº¿å¯†ç åº“</title>
  <style>
    :root{
      --bg:#0b0f17; --card:#121a2a; --card2:#0f1626; --text:#e8eefc; --muted:#9fb0d1;
      --line:#23304a; --accent:#5aa7ff; --danger:#ff5a7a; --ok:#5cffb3;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); background: radial-gradient(1200px 700px at 20% 0%, rgba(90,167,255,.18), transparent 55%),
        radial-gradient(900px 600px at 100% 20%, rgba(92,255,179,.12), transparent 60%), var(--bg);
      color:var(--text);
    }
    .wrap{max-width:1200px; margin:0 auto; padding:24px;}
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:18px;
    }
    .brand{display:flex; align-items:center; gap:12px;}
    .logo{
      width:40px; height:40px; border-radius:14px;
      background: linear-gradient(135deg, rgba(90,167,255,.9), rgba(92,255,179,.75));
      box-shadow: var(--shadow);
    }
    h1{font-size:18px; margin:0;}
    .subtitle{font-size:12px; color:var(--muted); margin-top:2px;}
    .row{display:flex; gap:16px;}
    .col{background:rgba(18,26,42,.9); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow);}
    .left{width:280px; padding:14px;}
    .mid{flex:1; min-width:360px;}
    .right{width:420px; padding:14px;}
    @media (max-width: 1100px){
      .row{flex-direction:column;}
      .left,.right{width:auto;}
    }

    .sectionTitle{font-size:12px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase; margin:10px 0 8px;}
    .btn{
      appearance:none; border:1px solid var(--line); background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; transition:.15s; font-weight:600;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{transform:translateY(-1px); border-color:rgba(90,167,255,.55);}
    .btn.primary{background:rgba(90,167,255,.18); border-color:rgba(90,167,255,.4);}
    .btn.danger{background:rgba(255,90,122,.14); border-color:rgba(255,90,122,.35);}
    .btn.ok{background:rgba(92,255,179,.12); border-color:rgba(92,255,179,.35);}
    .btn.small{padding:8px 10px; border-radius:10px; font-size:12px;}
    .btn.block{width:100%; justify-content:center;}
    .btn:disabled{opacity:.5; cursor:not-allowed; transform:none;}

    .input, .select, .textarea{
      width:100%; background:rgba(15,22,38,.8); color:var(--text);
      border:1px solid var(--line); border-radius:12px; padding:10px 12px; outline:none;
    }
    .input:focus, .select:focus, .textarea:focus{border-color:rgba(90,167,255,.6); box-shadow:0 0 0 3px rgba(90,167,255,.12);}
    .textarea{min-height:110px; resize:vertical;}
    .muted{color:var(--muted); font-size:12px; line-height:1.45;}
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border:1px solid var(--line); border-radius:999px;
      background:rgba(255,255,255,.03); font-size:12px; color:var(--muted);
    }
    .kpi{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px;}
    .kpi .pill b{color:var(--text); font-weight:800;}
    .divider{height:1px; background:var(--line); margin:12px 0;}

    .midHeader{padding:14px; border-bottom:1px solid var(--line); display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .midHeader .search{flex:1; display:flex; gap:10px; align-items:center;}
    .list{max-height:520px; overflow:auto;}
    .item{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:12px 14px; border-bottom:1px solid rgba(35,48,74,.65);
      cursor:pointer; transition:.12s;
    }
    .item:hover{background:rgba(255,255,255,.03);}
    .item.active{background:rgba(90,167,255,.10); border-bottom-color:rgba(90,167,255,.25);}
    .itemTitle{font-weight:800; font-size:14px;}
    .itemSub{font-size:12px; color:var(--muted); margin-top:3px;}
    .tagline{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;}
    .tag{
      font-size:11px; color:rgba(232,238,252,.9);
      padding:4px 8px; border-radius:999px; border:1px solid rgba(35,48,74,.8);
      background:rgba(255,255,255,.03);
    }

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    @media(max-width:520px){.grid2{grid-template-columns:1fr;}}
    .fieldLabel{font-size:12px; color:var(--muted); margin:10px 0 6px;}
    .mono{font-family:var(--mono);}

    .toast{
      position:fixed; right:18px; bottom:18px; z-index:9999;
      background:rgba(18,26,42,.92); border:1px solid var(--line);
      padding:10px 12px; border-radius:12px; box-shadow:var(--shadow);
      min-width:240px; display:none;
    }
    .toast.show{display:block; animation: pop .16s ease-out;}
    @keyframes pop{from{transform:translateY(8px); opacity:.0} to{transform:translateY(0); opacity:1}}
    .toast .t{font-weight:800; margin-bottom:2px;}
    .toast .d{font-size:12px; color:var(--muted);}

    /* Lock modal */
    .overlay{
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:18px; z-index:9998;
    }
    .overlay.show{display:flex;}
    .modal{
      width:min(560px, 100%); background:rgba(18,26,42,.96); border:1px solid var(--line);
      border-radius:20px; box-shadow:var(--shadow); padding:18px;
    }
    .modal h2{margin:0; font-size:16px;}
    .modal .muted{margin-top:6px;}
    .modal .actions{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;}
    .hint{
      margin-top:10px; padding:10px 12px; border-radius:14px;
      background:rgba(255,255,255,.03); border:1px dashed rgba(35,48,74,.9);
      font-size:12px; color:var(--muted); line-height:1.5;
    }
    .dangerText{color:rgba(255,90,122,.95); font-weight:800;}
    a{color:var(--accent)}

    /* âœ… æ›´å¯é çš„â€œéšè—å¯†ç â€æ–¹å¼ï¼šä¸åˆ‡æ¢ input typeï¼Œè€Œæ˜¯ç”¨ CSS è¿›è¡Œæ©ç  */
    .masked{
      -webkit-text-security: disc; /* Chrome/Edge/Safari */
      /* Firefox æ²¡æœ‰æ ‡å‡† text-securityï¼›è‡³å°‘ä¸ä¼šé˜»æ­¢æ˜¾ç¤ºé€»è¾‘ */
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>ç¦»çº¿å¯†ç åº“</h1>
          <div class="subtitle">æœ¬åœ° IndexedDB å­˜å‚¨ Â· AES-GCM åŠ å¯† Â· PBKDF2 æ´¾ç”Ÿ Â· å¯¼å…¥/å¯¼å‡ºåŠ å¯†å®¹å™¨</div>
        </div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
        <span class="pill" id="sessionPill">ğŸ”’ æœªè§£é”</span>
        <button class="btn small" id="btnLock">é”å®š</button>
        <button class="btn small" id="btnExport">å¯¼å‡ºï¼ˆåŠ å¯†ï¼‰</button>
        <button class="btn small" id="btnImport">å¯¼å…¥ï¼ˆåŠ å¯†ï¼‰</button>
      </div>
    </div>

    <div class="row">
      <!-- Left -->
      <div class="col left">
        <div class="sectionTitle">è¿‡æ»¤</div>
        <div class="fieldLabel">ç±»å‹</div>
        <select class="select" id="filterType">
          <option value="">å…¨éƒ¨</option>
        </select>

        <div class="fieldLabel">æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</div>
        <input class="input" id="filterTags" placeholder="ä¾‹å¦‚ï¼šå·¥ä½œ,æœåŠ¡å™¨" />

        <div class="divider"></div>

        <div class="sectionTitle">å¸¸ç”¨æ“ä½œ</div>
        <button class="btn primary block" id="btnNew">â• æ–°å»ºæ¡ç›®</button>
        <button class="btn block" id="btnGenerate">ğŸ² ç”Ÿæˆå¯†ç </button>

        <div class="hint">
          <div><b>å®‰å…¨æç¤º</b></div>
          <ul style="margin:8px 0 0 16px; padding:0;">
            <li>å»ºè®®ç¦»çº¿ä½¿ç”¨ï¼Œä¸å¼•å…¥ç¬¬ä¸‰æ–¹ CDNã€‚</li>
            <li>ä¸»å¯†ç ä¸å¯æ‰¾å›ï¼›å¿˜è®°å³æ— æ³•è§£å¯†ã€‚</li>
            <li>å¯¼å‡ºæ–‡ä»¶å»ºè®®å¦è¡Œå¤‡ä»½ï¼Œå¹¶æ³¨æ„æ³„éœ²é£é™©ï¼ˆè™½ç„¶æ˜¯åŠ å¯†çš„ï¼‰ã€‚</li>
          </ul>
        </div>

        <div class="divider"></div>

        <div class="sectionTitle">ç»Ÿè®¡</div>
        <div class="kpi">
          <span class="pill">æ¡ç›®æ•°ï¼š<b id="kpiCount">0</b></span>
          <span class="pill">ç±»å‹æ•°ï¼š<b id="kpiTypes">0</b></span>
          <span class="pill">å·²é”å®šï¼š<b id="kpiLocked">æ˜¯</b></span>
        </div>
      </div>

      <!-- Mid -->
      <div class="col mid">
        <div class="midHeader">
          <div class="search">
            <input class="input" id="search" placeholder="æœç´¢ï¼šæ ‡é¢˜ / è´¦å· / URL / æ ‡ç­¾ / å¤‡æ³¨" />
          </div>
          <button class="btn small ok" id="btnRefresh">â†» åˆ·æ–°</button>
        </div>
        <div class="list" id="list"></div>
      </div>

      <!-- Right -->
      <div class="col right">
        <div class="sectionTitle">è¯¦æƒ… / ç¼–è¾‘</div>

        <div class="grid2">
          <div>
            <div class="fieldLabel">ç±»å‹</div>
            <select class="select" id="fType"></select>
          </div>
          <div>
            <div class="fieldLabel">æ ‡é¢˜</div>
            <input class="input" id="fTitle" placeholder="ä¾‹å¦‚ï¼šGitHub - å·¥ä½œå·" />
          </div>
        </div>

        <div class="grid2">
          <div>
            <div class="fieldLabel">è´¦å·/ç”¨æˆ·å</div>
            <input class="input mono" id="fUsername" placeholder="email / username" />
          </div>
          <div>
            <div class="fieldLabel">URL / Host</div>
            <input class="input mono" id="fUrl" placeholder="https://..." />
          </div>
        </div>

        <div class="fieldLabel">æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</div>
        <input class="input" id="fTags" placeholder="å·¥ä½œ,ä¸ªäºº,æœåŠ¡å™¨..." />

        

        <div class="sectionTitle" style="margin-top:12px;">ç»‘å®šä¿¡æ¯ï¼ˆå¯é€‰ï¼‰</div>
        <div class="grid2">
          <div>
            <div class="fieldLabel">ç»‘å®šé‚®ç®±</div>
            <input class="input mono" id="fBindEmail" placeholder="name@example.com" />
          </div>
          <div>
            <div class="fieldLabel">ç»‘å®šæ‰‹æœºå·</div>
            <input class="input mono" id="fBindPhone" placeholder="+86 1XXXXXXXXXX" />
          </div>
        </div>
        <div class="grid2">
          <div>
            <div class="fieldLabel">ç»‘å®šå¾®ä¿¡</div>
            <input class="input mono" id="fBindWechat" placeholder="WeChat ID" />
          </div>
          <div>
            <div class="fieldLabel">ç»‘å®š QQ</div>
            <input class="input mono" id="fBindQQ" placeholder="QQ å·" />
          </div>
        </div>

        <div class="sectionTitle" style="margin-top:12px;">ä¼šå‘˜ï¼ˆå¯é€‰ï¼‰</div>
        <div class="grid2">
          <div>
            <div class="fieldLabel">ä¼šå‘˜åˆ°æœŸæ—¥æœŸ</div>
            <input class="input mono" id="fMemberExpire" type="date" />
          </div>
          <div>
            <div class="fieldLabel">ä¼šå‘˜å¤‡æ³¨</div>
            <input class="input" id="fMemberNote" placeholder="ä¾‹å¦‚ï¼šPro / å¹´è´¹ / å®¶åº­ç»„ / è®¢é˜…æ¸ é“" />
          </div>
        </div>

<div class="fieldLabel">å¯†ç  / å¯†é’¥</div>
        <div style="display:flex; gap:10px; align-items:center;">
          <!-- âœ… æ”¹ä¸º type=text + CSS æ©ç ï¼Œæ›´ç¨³å®š -->
          <input class="input mono masked" id="fSecret" type="text" placeholder="ç‚¹å‡»å³ä¾§æŒ‰é’®æ˜¾ç¤º/å¤åˆ¶" />
          <button class="btn small" id="btnToggleSecret">ğŸ‘ æ˜¾ç¤º</button>
          <button class="btn small" id="btnCopyUser">å¤åˆ¶è´¦å·</button>
          <button class="btn small" id="btnCopySecret">å¤åˆ¶å¯†ç </button>
        </div>
        <div class="muted" id="secretTimer" style="margin-top:6px; display:none;">å¯†ç å°†äº <b id="secretCountdown">15</b>s åè‡ªåŠ¨éšè—</div>

        <div class="fieldLabel">å¤‡æ³¨</div>
        <textarea class="textarea" id="fNotes" placeholder="ä¾‹å¦‚ï¼šæ¢å¤ç ä½ç½® / æ³¨å†Œæ‰‹æœºå·å°¾å· / å®‰å…¨é—®é¢˜æç¤ºï¼ˆä¸å»ºè®®å†™ç­”æ¡ˆï¼‰"></textarea>

        <div class="divider"></div>

        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn primary" id="btnSave">ğŸ’¾ ä¿å­˜</button>
          <button class="btn" id="btnCancel">å–æ¶ˆ</button>
          <button class="btn danger" id="btnDelete">ğŸ—‘ åˆ é™¤</button>
        </div>

        <div class="hint" style="margin-top:12px;">
          <div><b>å¤åˆ¶å‰ªè´´æ¿å»ºè®®</b></div>
          <div class="muted">å¤åˆ¶åå°½å¿«ç²˜è´´åˆ°å¯ä¿¡çª—å£ã€‚éƒ¨åˆ†æµè§ˆå™¨/ç³»ç»Ÿå¯èƒ½æ— æ³•è‡ªåŠ¨æ¸…ç©ºå‰ªè´´æ¿ï¼Œè¿™å±äºå¹³å°é™åˆ¶ã€‚</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast">
    <div class="t" id="toastTitle">æç¤º</div>
    <div class="d" id="toastDesc"></div>
  </div>

  <!-- Lock/Setup Modal -->
  <div class="overlay" id="overlay">
    <div class="modal">
      <h2 id="modalTitle">è§£é”å¯†ç åº“</h2>
      <div class="muted" id="modalDesc">è¾“å…¥ä¸»å¯†ç ä»¥è§£é”ã€‚æœ¬å·¥å…·ä¼šç”¨ PBKDF2 æ´¾ç”Ÿå¯†é’¥å¹¶åœ¨æœ¬åœ°è§£å¯†æ•°æ®ã€‚</div>

      <div class="divider"></div>

      <div class="fieldLabel">ä¸»å¯†ç </div>
      <input class="input mono" id="masterPassword" type="password" placeholder="ä¸»å¯†ç ï¼ˆä¸ä¼šä¸Šä¼ ç½‘ç»œï¼‰" />

      <div id="setupArea" style="display:none;">
        <div class="fieldLabel">ç¡®è®¤ä¸»å¯†ç </div>
        <input class="input mono" id="masterPassword2" type="password" placeholder="å†æ¬¡è¾“å…¥ä¸»å¯†ç " />
        <div class="hint">
          é¦–æ¬¡ä½¿ç”¨å°†åˆ›å»ºä¸€ä¸ªæ–°çš„åŠ å¯†å¯†ç åº“ã€‚<span class="dangerText">ä¸»å¯†ç ä¸å¯æ¢å¤</span>ï¼šå¿˜è®°åæ— æ³•è§£å¯†å†å²æ•°æ®ã€‚
        </div>
      </div>

      <div class="actions">
        <button class="btn primary" id="btnUnlock">è§£é”</button>
        <button class="btn ok" id="btnSetup">åˆ›å»ºæ–°åº“</button>
        <button class="btn" id="btnCloseModal">å…³é—­</button>
      </div>

      <div class="hint">
        <b>è‡ªåŠ¨é”å®š</b>ï¼šé»˜è®¤é—²ç½® <span class="mono">5 åˆ†é’Ÿ</span> è‡ªåŠ¨é”å®šï¼ˆå¯åœ¨ä»£ç é‡Œæ”¹ï¼‰ã€‚
      </div>
    </div>
  </div>

  <input type="file" id="fileInput" accept=".vault,.json,application/json" style="display:none;" />

<script>
(() => {

  /* =============================================================
     ç¦»çº¿å¯†ç åº“ 1.0 ç‰ˆæœ¬
     -------------------------------------------------------------
     æ¶æ„è¯´æ˜ï¼š
       - å­˜å‚¨å±‚ï¼šIndexedDB
       - åŠ å¯†å±‚ï¼šWebCrypto (PBKDF2 + AES-GCM)
       - ä¸»å¯†ç ä»…ç”¨äºæ´¾ç”Ÿ masterKey
       - vaultKey ç‹¬ç«‹å­˜åœ¨ï¼Œç”¨äºå®é™…æ•°æ®åŠ å¯†
       - åˆ—è¡¨ç¼“å­˜ä¸å« secret/notesï¼ˆé™ä½å†…å­˜é£é™©ï¼‰

     å®‰å…¨æ³¨æ„ï¼š
       - æµè§ˆå™¨ç¯å¢ƒæ— æ³•ä¿è¯å†…å­˜ç»å¯¹å®‰å…¨
       - è§£é”æœŸé—´æ•°æ®åœ¨å†…å­˜ä¸­å¯è¢«è°ƒè¯•å·¥å…·è®¿é—®
       - è¯·è‡ªè¡Œå¦¥å–„å¤‡ä»½å¯¼å‡ºæ–‡ä»¶
     ============================================================= */
  // =============================================================
  // å¸¸é‡ä¸å®‰å…¨é…ç½®åŒº
  // =============================================================
  // è¯´æ˜ï¼š
  //   æ‰€æœ‰å¯†ç å­¦å‚æ•°ä¸ç³»ç»Ÿè¡Œä¸ºå‚æ•°é›†ä¸­åœ¨æ­¤ï¼Œ
  //   è‹¥æœªæ¥å‡çº§ç®—æ³•æˆ–è°ƒæ•´å®‰å…¨ç­–ç•¥ï¼Œåº”ä¼˜å…ˆä¿®æ”¹æ­¤å¤„ã€‚
  // ---------------------------
  // Constants / Config
  // ---------------------------
  const DB_NAME = "offline_vault_db";
  const DB_VERSION = 1;
  const STORE_META = "meta";
  const STORE_ITEMS = "items";

  const KDF_ITERATIONS = 310000; // PBKDF2 iterations (stored in meta; constant is fallback)
  const AUTO_LOCK_MS = 5 * 60 * 1000; // 5 minutes
  const SECRET_SHOW_SECONDS = 15;

  // Import safety limits (UX + DoS guard)
  const IMPORT_MAX_BYTES = 20 * 1024 * 1024;      // 20MB hard limit
  const IMPORT_SOFT_MAX_ITEMS = 10000;            // ask for confirm beyond this

  const ITEM_TYPES = [
    "ç½‘ç«™è´¦å·", "é‚®ç®±", "æœåŠ¡å™¨/SSH", "API Key", "æ•°æ®åº“", "Wi-Fi", "è½¯ä»¶ License", "é“¶è¡Œå¡/é‡‘è", "å…¶ä»–"
  ];

  // =============================================================
  // è¿è¡Œæ—¶çŠ¶æ€ç®¡ç†
  // =============================================================
  // è¯´æ˜ï¼š
  //   æœ¬åŒºå˜é‡å…¨éƒ¨ä¸ºå†…å­˜æ€æ•°æ®ã€‚
  //   é”å®šæ—¶ä¼šä¸»åŠ¨æ¸…é™¤ key ä¸ç¼“å­˜å¼•ç”¨ï¼Œ
  //   ä»¥é™ä½æ˜æ–‡é•¿æœŸé©»ç•™é£é™©ã€‚
  // ---------------------------
  // State
  // ---------------------------
  let db = null;
  let unlocked = false;
  let masterKey = null;
  let vaultKey = null;
  let vaultMeta = null;

  // âœ… Cache ONLY non-sensitive index fields for listing/filtering/searching
  // {id,type,title,username,url,tags,createdAt,updatedAt}
  let itemsCache = [];

  // Active selection
  let activeId = null;

  // Full decrypted item for the active row only (contains secret/notes)
  let activeItemFull = null;

  // idle lock
  let idleTimer = null;

  // secret show timer
  let secretTimerHandle = null;
  let secretCountdownHandle = null;
  let remainingSecretSeconds = SECRET_SHOW_SECONDS;

  // Browser support: CSS masking vs password type
  const supportsTextSecurity = (() => {

  /* =============================================================
     ç¦»çº¿å¯†ç åº“ 1.0 ç‰ˆæœ¬
     -------------------------------------------------------------
     æ¶æ„è¯´æ˜ï¼š
       - å­˜å‚¨å±‚ï¼šIndexedDB
       - åŠ å¯†å±‚ï¼šWebCrypto (PBKDF2 + AES-GCM)
       - ä¸»å¯†ç ä»…ç”¨äºæ´¾ç”Ÿ masterKey
       - vaultKey ç‹¬ç«‹å­˜åœ¨ï¼Œç”¨äºå®é™…æ•°æ®åŠ å¯†
       - åˆ—è¡¨ç¼“å­˜ä¸å« secret/notesï¼ˆé™ä½å†…å­˜é£é™©ï¼‰

     å®‰å…¨æ³¨æ„ï¼š
       - æµè§ˆå™¨ç¯å¢ƒæ— æ³•ä¿è¯å†…å­˜ç»å¯¹å®‰å…¨
       - è§£é”æœŸé—´æ•°æ®åœ¨å†…å­˜ä¸­å¯è¢«è°ƒè¯•å·¥å…·è®¿é—®
       - è¯·è‡ªè¡Œå¦¥å–„å¤‡ä»½å¯¼å‡ºæ–‡ä»¶
     ============================================================= */
    try{
      return !!(window.CSS && CSS.supports && (CSS.supports("-webkit-text-security", "disc") || CSS.supports("text-security", "disc")));
    }catch{ return false; }
  })();

  // ---------------------------
  // UI helpers
  // ---------------------------
  const $ = (id) => document.getElementById(id);
  const toast = (title, desc="") => {
    $("toastTitle").textContent = title;
    $("toastDesc").textContent = desc;
    $("toast").classList.add("show");
    setTimeout(()=> $("toast").classList.remove("show"), 2400);
  };

  const formatDate = (ts) => {
    try{
      const d = new Date(ts);
      return d.toLocaleString();
    }catch{ return ""; }
  };


  const formatDateShort = (ymd) => {
    if (!ymd) return "";
    return ymd; // "YYYY-MM-DD"
  };

  const expiryStatus = (ymd) => {
    if (!ymd) return null;
    const t = Date.parse(ymd + "T00:00:00");
    if (!Number.isFinite(t)) return null;
    const today = new Date();
    const today0 = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();
    const diffDays = Math.floor((t - today0) / 86400000);
    if (diffDays < 0) return { kind: "expired", diffDays };
    if (diffDays <= 30) return { kind: "soon", diffDays };
    return { kind: "ok", diffDays };
  };

  const normalizeTags = (s) => (s || "")
    .split(",")
    .map(x => x.trim())
    .filter(Boolean)
    .filter((v, i, a) => a.indexOf(v) === i);

  const now = () => Date.now();

  const resetIdleTimer = () => {
    if (!unlocked) return;
    if (idleTimer) clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {

  /* =============================================================
     ç¦»çº¿å¯†ç åº“ 1.0 ç‰ˆæœ¬
     -------------------------------------------------------------
     æ¶æ„è¯´æ˜ï¼š
       - å­˜å‚¨å±‚ï¼šIndexedDB
       - åŠ å¯†å±‚ï¼šWebCrypto (PBKDF2 + AES-GCM)
       - ä¸»å¯†ç ä»…ç”¨äºæ´¾ç”Ÿ masterKey
       - vaultKey ç‹¬ç«‹å­˜åœ¨ï¼Œç”¨äºå®é™…æ•°æ®åŠ å¯†
       - åˆ—è¡¨ç¼“å­˜ä¸å« secret/notesï¼ˆé™ä½å†…å­˜é£é™©ï¼‰

     å®‰å…¨æ³¨æ„ï¼š
       - æµè§ˆå™¨ç¯å¢ƒæ— æ³•ä¿è¯å†…å­˜ç»å¯¹å®‰å…¨
       - è§£é”æœŸé—´æ•°æ®åœ¨å†…å­˜ä¸­å¯è¢«è°ƒè¯•å·¥å…·è®¿é—®
       - è¯·è‡ªè¡Œå¦¥å–„å¤‡ä»½å¯¼å‡ºæ–‡ä»¶
     ============================================================= */
      lockVault("é—²ç½®è¶…æ—¶è‡ªåŠ¨é”å®š");
    }, AUTO_LOCK_MS);
    updateSessionPill();
  };

  const updateSessionPill = () => {
    if (!unlocked) {
      $("sessionPill").textContent = "ğŸ”’ æœªè§£é”";
      $("kpiLocked").textContent = "æ˜¯";
      return;
    }
    $("sessionPill").textContent = "ğŸ”“ å·²è§£é”ï¼ˆé—²ç½®è‡ªåŠ¨é”å®šï¼‰";
    $("kpiLocked").textContent = "å¦";
  };

  // âœ… Unified secret masking behavior:
  // - If CSS text-security supported: keep type=text and toggle .masked
  // - Else (e.g. Firefox): toggle input type between password/text
  const hideSecret = () => {
    const el = $("fSecret");
    if (supportsTextSecurity) {
      el.type = "text";
      el.classList.add("masked");
    } else {
      el.classList.remove("masked");
      el.type = "password";
    }
    $("btnToggleSecret").textContent = "ğŸ‘ æ˜¾ç¤º";
    $("secretTimer").style.display = "none";
  };

  const showSecret = () => {
    const el = $("fSecret");
    if (supportsTextSecurity) {
      el.type = "text";
      el.classList.remove("masked");
    } else {
      el.classList.remove("masked");
      el.type = "text";
    }
    $("btnToggleSecret").textContent = "ğŸ™ˆ éšè—";
    startSecretAutoHide();
  };

  const clearSecretTimers = () => {
    if (secretTimerHandle) clearTimeout(secretTimerHandle);
    if (secretCountdownHandle) clearInterval(secretCountdownHandle);
    secretTimerHandle = null;
    secretCountdownHandle = null;
    remainingSecretSeconds = SECRET_SHOW_SECONDS;
    hideSecret();
  };

  const startSecretAutoHide = () => {
    if (secretTimerHandle) clearTimeout(secretTimerHandle);
    if (secretCountdownHandle) clearInterval(secretCountdownHandle);

    remainingSecretSeconds = SECRET_SHOW_SECONDS;
    $("secretTimer").style.display = "block";
    $("secretCountdown").textContent = String(remainingSecretSeconds);

    secretCountdownHandle = setInterval(() => {

  /* =============================================================
     ç¦»çº¿å¯†ç åº“ 1.0 ç‰ˆæœ¬
     -------------------------------------------------------------
     æ¶æ„è¯´æ˜ï¼š
       - å­˜å‚¨å±‚ï¼šIndexedDB
       - åŠ å¯†å±‚ï¼šWebCrypto (PBKDF2 + AES-GCM)
       - ä¸»å¯†ç ä»…ç”¨äºæ´¾ç”Ÿ masterKey
       - vaultKey ç‹¬ç«‹å­˜åœ¨ï¼Œç”¨äºå®é™…æ•°æ®åŠ å¯†
       - åˆ—è¡¨ç¼“å­˜ä¸å« secret/notesï¼ˆé™ä½å†…å­˜é£é™©ï¼‰

     å®‰å…¨æ³¨æ„ï¼š
       - æµè§ˆå™¨ç¯å¢ƒæ— æ³•ä¿è¯å†…å­˜ç»å¯¹å®‰å…¨
       - è§£é”æœŸé—´æ•°æ®åœ¨å†…å­˜ä¸­å¯è¢«è°ƒè¯•å·¥å…·è®¿é—®
       - è¯·è‡ªè¡Œå¦¥å–„å¤‡ä»½å¯¼å‡ºæ–‡ä»¶
     ============================================================= */
      remainingSecretSeconds -= 1;
      $("secretCountdown").textContent = String(Math.max(0, remainingSecretSeconds));
    }, 1000);

    secretTimerHandle = setTimeout(() => {

  /* =============================================================
     ç¦»çº¿å¯†ç åº“ 1.0 ç‰ˆæœ¬
     -------------------------------------------------------------
     æ¶æ„è¯´æ˜ï¼š
       - å­˜å‚¨å±‚ï¼šIndexedDB
       - åŠ å¯†å±‚ï¼šWebCrypto (PBKDF2 + AES-GCM)
       - ä¸»å¯†ç ä»…ç”¨äºæ´¾ç”Ÿ masterKey
       - vaultKey ç‹¬ç«‹å­˜åœ¨ï¼Œç”¨äºå®é™…æ•°æ®åŠ å¯†
       - åˆ—è¡¨ç¼“å­˜ä¸å« secret/notesï¼ˆé™ä½å†…å­˜é£é™©ï¼‰

     å®‰å…¨æ³¨æ„ï¼š
       - æµè§ˆå™¨ç¯å¢ƒæ— æ³•ä¿è¯å†…å­˜ç»å¯¹å®‰å…¨
       - è§£é”æœŸé—´æ•°æ®åœ¨å†…å­˜ä¸­å¯è¢«è°ƒè¯•å·¥å…·è®¿é—®
       - è¯·è‡ªè¡Œå¦¥å–„å¤‡ä»½å¯¼å‡ºæ–‡ä»¶
     ============================================================= */
      clearSecretTimers();
      toast("å·²è‡ªåŠ¨éšè—å¯†ç ");
    }, SECRET_SHOW_SECONDS * 1000);
  };

  // =============================================================
  // IndexedDB æ•°æ®å°è£…å±‚
  // =============================================================
  // ç»“æ„ï¼š
  //   meta  è¡¨ï¼šå­˜å‚¨åŠ å¯†å…ƒä¿¡æ¯ï¼ˆsalt / wrapped key ç­‰ï¼‰
  //   items è¡¨ï¼šå­˜å‚¨æ¯ä¸ªæ¡ç›®çš„åŠ å¯† payload
  //
  //   æ‰€æœ‰æ¡ç›®ä»¥ AES-GCM åŠ å¯† JSON å½¢å¼ä¿å­˜ã€‚
  // ---------------------------
  // IndexedDB
  // ---------------------------
  const openDB = () => new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (ev) => {
      const db = ev.target.result;
      if (!db.objectStoreNames.contains(STORE_META)) db.createObjectStore(STORE_META);
      if (!db.objectStoreNames.contains(STORE_ITEMS)) db.createObjectStore(STORE_ITEMS, { keyPath: "id" });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });

  const idbGet = (store, key) => new Promise((resolve, reject) => {
    const tx = db.transaction([store], "readonly");
    const st = tx.objectStore(store);
    const req = st.get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });

  const idbPut = (store, value, key=null) => new Promise((resolve, reject) => {
    const tx = db.transaction([store], "readwrite");
    const st = tx.objectStore(store);
    const req = key === null ? st.put(value) : st.put(value, key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
  });

  const idbDelete = (store, key) => new Promise((resolve, reject) => {
    const tx = db.transaction([store], "readwrite");
    const st = tx.objectStore(store);
    const req = st.delete(key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
  });

  const idbGetAll = (store) => new Promise((resolve, reject) => {
    const tx = db.transaction([store], "readonly");
    const st = tx.objectStore(store);
    const req = st.getAll();
    req.onsuccess = () => resolve(req.result || []);
    req.onerror = () => reject(req.error);
  });

  // =============================================================
  // åŠ å¯†æ¨¡å—ï¼ˆWebCrypto APIï¼‰
  // =============================================================
  // æ•°æ®æµç¨‹ï¼š
  //   ä¸»å¯†ç  â†’ PBKDF2 â†’ masterKey
  //   masterKey â†’ è§£åŒ… â†’ vaultKey
  //   vaultKey â†’ AES-GCM â†’ æ¯æ¡æ¡ç›®
  //
  // è®¾è®¡åŸåˆ™ï¼š
  //   ä¸»å¯†ç æ°¸ä¸ç›´æ¥ç”¨äºæ•°æ®åŠ å¯†
  //   é€šè¿‡ vaultKey å®ç°ç»“æ„åˆ†ç¦»
  // ---------------------------
  // Crypto helpers (WebCrypto)
  // ---------------------------
  const enc = new TextEncoder();
  const dec = new TextDecoder();

  const b64e = (buf) => {
    const bytes = new Uint8Array(buf);
    let s = "";
    for (let i=0;i<bytes.length;i++) s += String.fromCharCode(bytes[i]);
    return btoa(s);
  };
  const b64d = (str) => {
    const bin = atob(str);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  };

  const randomBytes = (n) => crypto.getRandomValues(new Uint8Array(n));

  const deriveMasterKey = async (password, saltB64, iterations) => {
    const salt = new Uint8Array(b64d(saltB64));
    const baseKey = await crypto.subtle.importKey(
      "raw",
      enc.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations, hash: "SHA-256" },
      baseKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  };

  const wrapVaultKey = async (masterKey, vaultKey) => {
    const iv = randomBytes(12);
    const rawVault = await crypto.subtle.exportKey("raw", vaultKey);
    const wrapped = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, masterKey, rawVault);
    return { iv: b64e(iv.buffer), wrapped: b64e(wrapped) };
  };

  const unwrapVaultKey = async (masterKey, wrappedB64, ivB64) => {
    const wrapped = b64d(wrappedB64);
    const iv = new Uint8Array(b64d(ivB64));
    const raw = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, masterKey, wrapped);
    return crypto.subtle.importKey("raw", raw, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
  };

  const encryptJSON = async (key, obj) => {
    const iv = randomBytes(12);
    const plaintext = enc.encode(JSON.stringify(obj));
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plaintext);
    return { iv: b64e(iv.buffer), ciphertext: b64e(ciphertext) };
  };

  const decryptJSON = async (key, payload) => {
    const iv = new Uint8Array(b64d(payload.iv));
    const ciphertext = b64d(payload.ciphertext);
    const plaintext = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
    return JSON.parse(dec.decode(plaintext));
  };

  // ---------------------------
  // Vault meta
  // ---------------------------
  const loadVaultMeta = async () => {
    return await idbGet(STORE_META, "vault_meta");
  };

  const createNewVault = async (password) => {
    const salt = randomBytes(16);
    const saltB64 = b64e(salt.buffer);

    const mk = await deriveMasterKey(password, saltB64, KDF_ITERATIONS);
    const vk = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
    const wrapped = await wrapVaultKey(mk, vk);

    const meta = {
      schema_version: 1,
      kdf: { name: "PBKDF2", hash: "SHA-256", iterations: KDF_ITERATIONS },
      salt: saltB64,
      wrappedVaultKey: wrapped.wrapped,
      wrappedVaultKeyIv: wrapped.iv,
      createdAt: now(),
      updatedAt: now()
    };

    await idbPut(STORE_META, meta, "vault_meta");
    return { meta, mk, vk };
  };

  // =============================================================
  // æ¡ç›®æ•°æ®å±‚
  // =============================================================
  // å®‰å…¨è®¾è®¡é‡ç‚¹ï¼š
  //   itemsCache ä»…ä¿å­˜ç´¢å¼•å­—æ®µ
  //   secret ä¸ notes ä¸å¸¸é©»å†…å­˜
  //   é€‰ä¸­æ¡ç›®æ—¶æ‰è§£å¯†å®Œæ•´æ•°æ®
  //
  // è¿™æ ·å¯ä»¥å‡å°‘ï¼š
  //   - æµè§ˆå™¨æ‰©å±•è¯»å–é£é™©
  //   - æ‰¹é‡å†…å­˜æ‰«æé£é™©
  // ---------------------------
  // Items
  // ---------------------------
  const newId = () => {
    const b = randomBytes(16);
    return Array.from(b).map(x => x.toString(16).padStart(2,"0")).join("");
  };

  const getItemRow = async (id) => {
    return await idbGet(STORE_ITEMS, id);
  };

  // âœ… Load list cache with decrypted index fields ONLY; do not retain secret/notes in memory
  const loadAllItemsIndex = async () => {
    const rows = await idbGetAll(STORE_ITEMS);
    const out = [];
    let failed = 0;

    for (const row of rows) {
      try{
        const obj = await decryptJSON(vaultKey, row.payload);
        out.push({
          id: obj.id,
          type: obj.type,
          title: obj.title,
          username: obj.username,
          url: obj.url,
          tags: Array.isArray(obj.tags) ? obj.tags : [],
          bindEmail: obj.bindEmail || "",
          bindPhone: obj.bindPhone || "",
          bindWechat: obj.bindWechat || "",
          bindQQ: obj.bindQQ || "",
          memberExpire: obj.memberExpire || "",
          memberNote: obj.memberNote || "",
          createdAt: obj.createdAt,
          updatedAt: obj.updatedAt
        });
      }catch(e){
        failed += 1;
        console.error("decrypt item failed", row?.id, e);
      }
    }

    out.sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));
    if (failed) {
      toast("éƒ¨åˆ†æ¡ç›®æ— æ³•è§£å¯†", `å¤±è´¥ ${failed} æ¡ï¼ˆå¯èƒ½å¯†ç ä¸åŒ¹é…æˆ–æ•°æ®æŸåï¼‰`);
    }
    return out;
  };

  const decryptItemById = async (id) => {
    const row = await getItemRow(id);
    if (!row) throw new Error("æ¡ç›®ä¸å­˜åœ¨æˆ–å·²åˆ é™¤");
    return await decryptJSON(vaultKey, row.payload);
  };

  const upsertItem = async (itemFull) => {
    const payload = await encryptJSON(vaultKey, itemFull);
    await idbPut(STORE_ITEMS, { id: itemFull.id, payload });
  };

  const deleteItem = async (id) => {
    await idbDelete(STORE_ITEMS, id);
  };

  // ---------------------------
  // UI
  // ---------------------------
  const escapeHtml = (s) => (s || "").replace(/[&<>"']/g, (c) => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));

  const fillTypeSelects = () => {
    const opts = ['<option value="">å…¨éƒ¨</option>'].concat(
      ITEM_TYPES.map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`)
    ).join("");
    $("filterType").innerHTML = opts;

    $("fType").innerHTML = ITEM_TYPES.map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join("");
  };

  const computeStats = (items) => {
    $("kpiCount").textContent = String(items.length);
    const types = new Set(items.map(x=>x.type).filter(Boolean));
    $("kpiTypes").textContent = String(types.size);
  };

  const filteredItems = () => {
    const q = ($("search").value || "").trim().toLowerCase();
    const fType = $("filterType").value;
    const fTags = normalizeTags($("filterTags").value).map(x => x.toLowerCase());

    return itemsCache.filter(it => {
      if (fType && it.type !== fType) return false;
      if (fTags.length) {
        const tags = (it.tags || []).map(x=>x.toLowerCase());
        for (const t of fTags) if (!tags.includes(t)) return false;
      }
      if (!q) return true;

      // âœ… Search only index fields (does not decrypt notes/secret)
      const hay = [
        it.title, it.username, it.url, (it.tags || []).join(","), it.type,
        it.bindEmail, it.bindPhone, it.bindWechat, it.bindQQ,
        it.memberExpire, it.memberNote
      ].join(" ").toLowerCase();

      return hay.includes(q);
    });
  };

  const renderList = () => {
    const list = $("list");
    list.innerHTML = "";
    const items = filteredItems();
    computeStats(itemsCache);

    if (!unlocked) {
      list.innerHTML = `<div style="padding:16px;" class="muted">æœªè§£é”ã€‚æŒ‰ <span class="mono">Ctrl/Cmd+L</span> è§£é”ã€‚</div>`;
      return;
    }
    if (!items.length) {
      list.innerHTML = `<div style="padding:16px;" class="muted">æš‚æ— æ¡ç›®ã€‚ç‚¹å‡»â€œæ–°å»ºæ¡ç›®â€å¼€å§‹ã€‚</div>`;
      return;
    }

    for (const it of items) {
      const div = document.createElement("div");
      div.className = "item" + (it.id === activeId ? " active" : "");
      div.onclick = () => { selectItem(it.id); };

      const left = document.createElement("div");
      left.style.minWidth = "0";
      left.innerHTML = `
        <div class="itemTitle">${escapeHtml(it.title || "(æ— æ ‡é¢˜)")}</div>
        <div class="itemSub">
          ${escapeHtml(it.type || "")}
          ${it.username ? " Â· " + escapeHtml(it.username) : ""}
          ${it.url ? " Â· " + escapeHtml(it.url) : ""}
        </div>
        <div class="itemSub">æ›´æ–°ï¼š${escapeHtml(formatDate(it.updatedAt || it.createdAt || 0))}</div>
      `;

      const right = document.createElement("div");
      right.className = "tagline";
      const tags = (it.tags || []).slice(0,4);
      const exp = expiryStatus(it.memberExpire);
      const expTag = exp
        ? (exp.kind === "expired"
            ? `<span class="tag" title="å·²è¿‡æœŸ">â° å·²è¿‡æœŸ</span>`
            : (exp.kind === "soon"
                ? `<span class="tag" title="å‰©ä½™ ${Math.max(0, exp.diffDays)} å¤©">â° åˆ°æœŸ ${escapeHtml(formatDateShort(it.memberExpire))}</span>`
                : `<span class="tag" title="åˆ°æœŸæ—¥">â° ${escapeHtml(formatDateShort(it.memberExpire))}</span>`
              )
          )
        : "";

      right.innerHTML = expTag + tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join("") +
        ((it.tags||[]).length > 4 ? `<span class="tag">+${(it.tags||[]).length-4}</span>` : "");

div.appendChild(left);
      div.appendChild(right);
      list.appendChild(div);
    }
  };

  const clearForm = () => {
    activeId = null;
    activeItemFull = null;

    $("fType").value = ITEM_TYPES[0];
    $("fTitle").value = "";
    $("fUsername").value = "";
    $("fUrl").value = "";
    $("fTags").value = "";
    $("fSecret").value = "";
    $("fNotes").value = "";

    
    
    $("fBindEmail").value = "";
    $("fBindPhone").value = "";
    $("fBindWechat").value = "";
    $("fBindQQ").value = "";
    $("fMemberExpire").value = "";
    $("fMemberNote").value = "";
$("fBindEmail").value = "";
    $("fBindPhone").value = "";
    $("fBindWechat").value = "";
    $("fBindQQ").value = "";
    $("fMemberExpire").value = "";
    $("fMemberNote").value = "";
clearSecretTimers();
    updateButtons();
  };

  const isFormEmpty = () => {
    return !($("fTitle").value || $("fUsername").value || $("fUrl").value || $("fTags").value ||
      $("fBindEmail").value || $("fBindPhone").value || $("fBindWechat").value || $("fBindQQ").value ||
      $("fMemberExpire").value || $("fMemberNote").value ||
      $("fSecret").value || $("fNotes").value);
  };

  const updateButtons = () => {
    const hasActive = !!activeId;
    $("btnDelete").disabled = !hasActive;
    $("btnCancel").disabled = !hasActive && isFormEmpty();
    $("btnSave").disabled = !unlocked;
    $("btnCopyUser").disabled = !unlocked;
    $("btnCopySecret").disabled = !unlocked;
    $("btnToggleSecret").disabled = !unlocked;
  };

  const selectItem = async (id) => {
    if (!unlocked) return;
    const idx = itemsCache.find(x => x.id === id);
    if (!idx) return;

    // Clear visible secret immediately to avoid showing stale secrets during async decrypt
    clearSecretTimers();
    $("fSecret").value = "";
    $("fNotes").value = "";

    
    $("fBindEmail").value = "";
    $("fBindPhone").value = "";
    $("fBindWechat").value = "";
    $("fBindQQ").value = "";
    $("fMemberExpire").value = "";
    $("fMemberNote").value = "";
activeId = id;
    renderList();
    updateButtons();

    try{
      const full = await decryptItemById(id);
      activeItemFull = full;

      $("fType").value = full.type || ITEM_TYPES[0];
      $("fTitle").value = full.title || "";
      $("fUsername").value = full.username || "";
      $("fUrl").value = full.url || "";
      $("fTags").value = (full.tags || []).join(", ");
      $("fSecret").value = full.secret || "";
      $("fNotes").value = full.notes || "";

      
      $("fBindEmail").value = full.bindEmail || "";
      $("fBindPhone").value = full.bindPhone || "";
      $("fBindWechat").value = full.bindWechat || "";
      $("fBindQQ").value = full.bindQQ || "";
      $("fMemberExpire").value = full.memberExpire || "";
      $("fMemberNote").value = full.memberNote || "";
clearSecretTimers();
      updateButtons();
    }catch(e){
      toast("è¯»å–æ¡ç›®å¤±è´¥", String(e?.message || e));
    }
  };

  const readFormFull = () => {
    const id = activeId || newId();
    const ts = now();

    // Try to preserve createdAt from active item or cache
    const existingIdx = itemsCache.find(x=>x.id===id);
    const existingCreatedAt = activeItemFull?.createdAt || existingIdx?.createdAt;

    return {
      id,
      type: $("fType").value || "å…¶ä»–",
      title: ($("fTitle").value || "").trim(),
      username: ($("fUsername").value || "").trim(),
      url: ($("fUrl").value || "").trim(),
      tags: normalizeTags($("fTags").value),
      secret: $("fSecret").value || "",
      notes: ($("fNotes").value || "").trim(),
      bindEmail: ($("fBindEmail").value || "").trim(),
      bindPhone: ($("fBindPhone").value || "").trim(),
      bindWechat: ($("fBindWechat").value || "").trim(),
      bindQQ: ($("fBindQQ").value || "").trim(),
      memberExpire: ($("fMemberExpire").value || "").trim(),
      memberNote: ($("fMemberNote").value || "").trim(),

      createdAt: existingCreatedAt || ts,
      updatedAt: ts
    };
  };

  const indexFromFull = (full) => ({
    id: full.id,
    type: full.type,
    title: full.title,
    username: full.username,
    url: full.url,
    tags: Array.isArray(full.tags) ? full.tags : [],
    bindEmail: full.bindEmail || "",
    bindPhone: full.bindPhone || "",
    bindWechat: full.bindWechat || "",
    bindQQ: full.bindQQ || "",
    memberExpire: full.memberExpire || "",
    memberNote: full.memberNote || "",
    createdAt: full.createdAt,
    updatedAt: full.updatedAt
  });

  // ---------------------------
  // Clipboard
  // ---------------------------
  const copyText = async (text, label="å·²å¤åˆ¶") => {
    resetIdleTimer();
    if (!text) { toast("æ²¡æœ‰å¯å¤åˆ¶å†…å®¹"); return; }
    try{
      await navigator.clipboard.writeText(text);
      toast(label, "å·²å†™å…¥å‰ªè´´æ¿ï¼ˆå»ºè®®å°½å¿«ç²˜è´´ï¼‰");

      // Best-effort: try to overwrite clipboard later (platform may deny)
      setTimeout(async () => {
        try{ await navigator.clipboard.writeText(""); }catch{}
      }, 30_000);
    }catch(e){
      try{
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        toast(label, "å·²å†™å…¥å‰ªè´´æ¿ï¼ˆfallbackï¼‰");
      }catch(err){
        toast("å¤åˆ¶å¤±è´¥", "æµè§ˆå™¨å¯èƒ½ç¦æ­¢å‰ªè´´æ¿è®¿é—®");
      }
    }
  };

  // =============================================================
  // é”å®š / è§£é”æœºåˆ¶
  // =============================================================
  // è§£é”ï¼š
  //   è¾“å…¥ä¸»å¯†ç  â†’ æ´¾ç”Ÿ key â†’ è§£åŒ… vaultKey â†’ åŠ è½½ç´¢å¼•
  //
  // é”å®šï¼š
  //   æ¸…ç©º key â†’ æ¸…ç©ºç¼“å­˜ â†’ æ›´æ–° UI
  //
  // è‡ªåŠ¨é”å®šï¼š
  //   åŸºäºç”¨æˆ·äº¤äº’äº‹ä»¶åˆ·æ–° idleTimer
  // ---------------------------
  // Lock / Unlock
  // ---------------------------
  const showModal = async () => {
    $("overlay").classList.add("show");
    $("masterPassword").value = "";
    $("masterPassword2").value = "";
    $("masterPassword").focus();

    const meta = await loadVaultMeta();
    if (!meta) {
      $("modalTitle").textContent = "åˆ›å»ºæ–°å¯†ç åº“";
      $("modalDesc").textContent = "é¦–æ¬¡ä½¿ç”¨ï¼šè¯·è®¾ç½®ä¸»å¯†ç ã€‚æ•°æ®å°†åŠ å¯†ä¿å­˜åœ¨æœ¬æœºæµè§ˆå™¨çš„ IndexedDBã€‚";
      $("setupArea").style.display = "block";
      $("btnSetup").style.display = "inline-flex";
    } else {
      $("modalTitle").textContent = "è§£é”å¯†ç åº“";
      $("modalDesc").textContent = "è¾“å…¥ä¸»å¯†ç ä»¥è§£é”ã€‚ä¸»å¯†ç ä¸ä¼šä¸Šä¼ ç½‘ç»œã€‚";
      $("setupArea").style.display = "none";
      $("btnSetup").style.display = "none";
    }
  };

  const hideModal = () => {
    $("overlay").classList.remove("show");
  };

  const hardClearSensitive = () => {
    // Best-effort: remove references to sensitive strings/objects
    activeItemFull = null;
    $("fSecret").value = "";
    $("fNotes").value = "";
    
    $("fBindEmail").value = "";
    $("fBindPhone").value = "";
    $("fBindWechat").value = "";
    $("fBindQQ").value = "";
    $("fMemberExpire").value = "";
    $("fMemberNote").value = "";
clearSecretTimers();
  };

  const lockVault = (reason="å·²é”å®š") => {
    unlocked = false;
    masterKey = null;
    vaultKey = null;
    vaultMeta = null;

    itemsCache = [];
    activeId = null;
    hardClearSensitive();
    clearForm();

    renderList();
    updateSessionPill();
    updateButtons();

    toast(reason);
  };

  const unlockVault = async (password) => {
    const meta = await loadVaultMeta();
    if (!meta) throw new Error("Vault not initialized");

    const iterations = meta?.kdf?.iterations || KDF_ITERATIONS;
    const mk = await deriveMasterKey(password, meta.salt, iterations);
    const vk = await unwrapVaultKey(mk, meta.wrappedVaultKey, meta.wrappedVaultKeyIv);

    masterKey = mk;
    vaultKey = vk;
    vaultMeta = meta;
    unlocked = true;

    // Load only index cache (non-sensitive)
    itemsCache = await loadAllItemsIndex();

    activeId = null;
    clearForm();
    renderList();
    updateSessionPill();
    updateButtons();
    resetIdleTimer();
  };

  // =============================================================
  // å¯¼å…¥ / å¯¼å‡ºæ¨¡å—
  // =============================================================
  // ç‰¹ç‚¹ï¼š
  //   - å¯¼å‡ºæ–‡ä»¶ä»ä¸ºåŠ å¯†çŠ¶æ€
  //   - å¼ºæ ¡éªŒ JSON ç»“æ„ä¸å¤§å°
  //   - æ— æ‰¾å›å¯†ç åŠŸèƒ½
  //
  // è¯´æ˜ï¼š
  //   è‹¥ä¸»å¯†ç ä¸¢å¤±ï¼Œæ•°æ®æ— æ³•æ¢å¤ã€‚
  // ---------------------------
  // Export / Import
  // ---------------------------
  const exportVault = async () => {
    resetIdleTimer();
    if (!unlocked) { toast("è¯·å…ˆè§£é”"); return; }

    const encRows = await idbGetAll(STORE_ITEMS);
    const meta = await loadVaultMeta();

    const container = {
      format: "offline-vault",
      version: 1,
      exportedAt: now(),
      meta,
      items: encRows
    };

    const blob = new Blob([JSON.stringify(container, null, 2)], { type: "application/json" });
    const a = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g,"-");
    a.download = `vault-${ts}.vault.json`;
    a.href = URL.createObjectURL(blob);
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    toast("å·²å¯¼å‡ºï¼ˆåŠ å¯†ï¼‰", "æ–‡ä»¶åŒ…å«å¯†æ–‡ä¸åŠ å¯†å…ƒæ•°æ®ï¼ˆéœ€åŸä¸»å¯†ç è§£é”ï¼‰");
  };

  const assertB64 = (s) => {
    if (typeof s !== "string" || !s.length) return false;
    // Basic sanity; also ensure atob doesn't throw
    try{ atob(s); return true; }catch{ return false; }
  };

  const validateImport = (obj) => {
    if (obj?.format !== "offline-vault" || obj?.version !== 1) throw new Error("ä¸æ”¯æŒçš„å¯¼å…¥æ ¼å¼/ç‰ˆæœ¬");
    if (!obj.meta || !Array.isArray(obj.items)) throw new Error("å¯¼å…¥æ–‡ä»¶ç¼ºå°‘å¿…è¦å­—æ®µ");

    const m = obj.meta;
    if (m?.schema_version !== 1) throw new Error("ä¸æ”¯æŒçš„ schema_version");
    if (!m?.kdf || m.kdf.name !== "PBKDF2") throw new Error("ä¸æ”¯æŒçš„ KDF");
    if (typeof m?.kdf?.iterations !== "number" || m.kdf.iterations < 100_000) throw new Error("KDF iterations éæ³•");
    if (!assertB64(m?.salt)) throw new Error("salt éæ³•");
    if (!assertB64(m?.wrappedVaultKey) || !assertB64(m?.wrappedVaultKeyIv)) throw new Error("wrappedVaultKey/IV éæ³•");
  };

  const importVault = async (file) => {
    if (file.size > IMPORT_MAX_BYTES) {
      throw new Error(`æ–‡ä»¶è¿‡å¤§ï¼ˆ>${Math.floor(IMPORT_MAX_BYTES/1024/1024)}MBï¼‰ï¼Œä¸ºé¿å…å¡æ­»å·²æ‹’ç»å¯¼å…¥`);
    }

    const text = await file.text();
    let obj;
    try{ obj = JSON.parse(text); }catch{ throw new Error("æ–‡ä»¶ä¸æ˜¯æœ‰æ•ˆ JSON"); }
    validateImport(obj);

    if (obj.items.length > IMPORT_SOFT_MAX_ITEMS) {
      const ok = confirm(`å¯¼å…¥æ–‡ä»¶åŒ…å« ${obj.items.length} æ¡å¯†æ–‡è®°å½•ï¼Œå¯èƒ½å¯¼è‡´æµè§ˆå™¨å¡é¡¿ã€‚\nä»è¦ç»§ç»­å¯¼å…¥å—ï¼Ÿ`);
      if (!ok) throw new Error("ç”¨æˆ·å–æ¶ˆå¯¼å…¥");
    }

    await idbPut(STORE_META, obj.meta, "vault_meta");

    const tx = db.transaction([STORE_ITEMS], "readwrite");
    await new Promise((resolve, reject) => {
      const req = tx.objectStore(STORE_ITEMS).clear();
      req.onsuccess = () => resolve(true);
      req.onerror = () => reject(req.error);
    });

    // Write rows with minimal validation
    let kept = 0;
    for (const row of obj.items) {
      if (row?.id && row?.payload?.iv && row?.payload?.ciphertext && assertB64(row.payload.iv) && assertB64(row.payload.ciphertext)) {
        await idbPut(STORE_ITEMS, row);
        kept += 1;
      }
    }

    lockVault("å·²å¯¼å…¥ï¼Œè¯·è§£é”");
    toast("å¯¼å…¥æˆåŠŸ", `å·²å†™å…¥ ${kept} æ¡è®°å½•ï¼›è¯·ä½¿ç”¨å¯¹åº”ä¸»å¯†ç è§£é”`);
  };

  // ---------------------------
  // Password generator
  // ---------------------------
  const generatePassword = (len=20) => {
    const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789" +
      "!@#$%^&*()-_=+[]{};:,.?/|~";
    const bytes = randomBytes(len);
    let out = "";
    for (let i=0;i<len;i++) out += chars[bytes[i] % chars.length];
    return out;
  };

  // ---------------------------
  // Events
  // ---------------------------
  const bindEvents = () => {
    ["click","keydown","mousemove","scroll","touchstart"].forEach(ev => {
      document.addEventListener(ev, () => resetIdleTimer(), { passive:true });
    });

    $("btnLock").onclick = () => lockVault("å·²æ‰‹åŠ¨é”å®š");
    $("btnExport").onclick = exportVault;
    $("btnImport").onclick = () => { $("fileInput").click(); };
    $("fileInput").addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      e.target.value = "";
      if (!f) return;
      try{
        await importVault(f);
      }catch(err){
        toast("å¯¼å…¥å¤±è´¥", String(err?.message || err));
      }
    });

    $("btnRefresh").onclick = async () => {
      if (!unlocked) { toast("è¯·å…ˆè§£é”"); return; }
      itemsCache = await loadAllItemsIndex();
      renderList();
      toast("å·²åˆ·æ–°");
    };

    $("btnNew").onclick = () => {
      if (!unlocked) { showModal(); return; }
      clearForm();
      toast("æ–°å»ºæ¡ç›®", "åœ¨å³ä¾§å¡«å†™å¹¶ä¿å­˜");
    };

    $("btnGenerate").onclick = () => {
      if (!unlocked) { toast("è¯·å…ˆè§£é”"); return; }
      const pw = generatePassword(20);
      $("fSecret").value = pw;
      clearSecretTimers(); // ç”Ÿæˆåé»˜è®¤ä»éšè—
      toast("å·²ç”Ÿæˆå¯†ç ", "å»ºè®®ä¿å­˜åå†å¤åˆ¶ä½¿ç”¨");
      updateButtons();
    };

    $("search").addEventListener("input", renderList);
    $("filterType").addEventListener("change", renderList);
    $("filterTags").addEventListener("input", renderList);

    $("btnCopyUser").onclick = () => copyText($("fUsername").value, "å·²å¤åˆ¶è´¦å·");
    $("btnCopySecret").onclick = async () => {
      // Ensure active full is present; if not, it might be a new unsaved entry
      await copyText($("fSecret").value, "å·²å¤åˆ¶å¯†ç ");
    };

    $("btnToggleSecret").onclick = () => {
      if (!unlocked) return;
      const el = $("fSecret");
      const hidden = supportsTextSecurity ? el.classList.contains("masked") : (el.type === "password");
      if (hidden) showSecret(); else clearSecretTimers();
    };

    $("btnSave").onclick = async () => {
      if (!unlocked) { toast("è¯·å…ˆè§£é”"); return; }
      const itemFull = readFormFull();
      if (!itemFull.title && !itemFull.username && !itemFull.url) {
        toast("æ— æ³•ä¿å­˜", "è‡³å°‘å¡«å†™æ ‡é¢˜/è´¦å·/URL ä¹‹ä¸€");
        return;
      }

      await upsertItem(itemFull);

      // Update list cache (non-sensitive)
      const idxObj = indexFromFull(itemFull);
      const idx = itemsCache.findIndex(x=>x.id===itemFull.id);
      if (idx >= 0) itemsCache[idx] = idxObj; else itemsCache.push(idxObj);
      itemsCache.sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));

      activeId = itemFull.id;
      activeItemFull = itemFull;
      clearSecretTimers(); // ä¿å­˜åå›åˆ°éšè—
      renderList();
      toast("å·²ä¿å­˜", itemFull.title || "(æ— æ ‡é¢˜)");
    };

    $("btnCancel").onclick = async () => {
      if (!unlocked) { clearForm(); return; }

      if (activeId) {
        // Reload from DB to revert changes, ensures we don't rely on old in-memory secret
        try{
          await selectItem(activeId);
          toast("å·²å–æ¶ˆä¿®æ”¹");
        }catch{
          clearForm();
          toast("å·²æ¸…ç©º");
        }
      } else {
        clearForm();
        toast("å·²æ¸…ç©º");
      }
    };

    $("btnDelete").onclick = async () => {
      if (!unlocked) return;
      if (!activeId) return;

      const itIdx = itemsCache.find(x=>x.id===activeId);
      const name = itIdx?.title || "(æ— æ ‡é¢˜)";
      const ok = confirm(`ç¡®è®¤åˆ é™¤ï¼š${name} ï¼Ÿ\nï¼ˆæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼‰`);
      if (!ok) return;

      await deleteItem(activeId);

      itemsCache = itemsCache.filter(x=>x.id!==activeId);
      activeId = null;
      hardClearSensitive();
      clearForm();
      renderList();
      toast("å·²åˆ é™¤", name);
    };

    $("btnUnlock").onclick = async () => {
      try{
        const pw = $("masterPassword").value;
        if (!pw) { toast("è¯·è¾“å…¥ä¸»å¯†ç "); return; }
        toast("æ­£åœ¨è§£é”â€¦", "æ­£åœ¨æ´¾ç”Ÿå¯†é’¥å¹¶è§£å¯†ç´¢å¼•");
        await unlockVault(pw);
        hideModal();
        toast("è§£é”æˆåŠŸ");
      }catch(err){
        toast("è§£é”å¤±è´¥", "ä¸»å¯†ç é”™è¯¯æˆ–æ•°æ®æŸå");
      }
    };

    $("btnSetup").onclick = async () => {
      try{
        const pw1 = $("masterPassword").value;
        const pw2 = $("masterPassword2").value;
        if (!pw1 || pw1.length < 10) {
          toast("ä¸»å¯†ç è¿‡çŸ­", "å»ºè®®è‡³å°‘ 10 ä½ï¼ŒåŒ…å«å¤§å°å†™/æ•°å­—/ç¬¦å·");
          return;
        }
        if (pw1 !== pw2) {
          toast("ä¸¤æ¬¡è¾“å…¥ä¸ä¸€è‡´");
          return;
        }
        const { meta, mk, vk } = await createNewVault(pw1);
        vaultMeta = meta;
        masterKey = mk;
        vaultKey = vk;
        unlocked = true;
        itemsCache = [];
        activeId = null;
        hardClearSensitive();
        clearForm();
        renderList();
        updateSessionPill();
        updateButtons();
        resetIdleTimer();
        hideModal();
        toast("å·²åˆ›å»ºå¹¶è§£é”", "è¯·ç«‹å³å¯¼å‡ºå¤‡ä»½ï¼ˆåŠ å¯†ï¼‰");
      }catch(err){
        toast("åˆ›å»ºå¤±è´¥", String(err?.message || err));
      }
    };

    $("btnCloseModal").onclick = hideModal;

    document.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "l") {
        e.preventDefault();
        showModal();
      }
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden && unlocked) {
        lockVault("é¡µé¢ç¦»å¼€å·²é”å®š");
      }
    });

    ["fType","fTitle","fUsername","fUrl","fTags","fBindEmail","fBindPhone","fBindWechat","fBindQQ","fMemberExpire","fMemberNote","fSecret","fNotes"].forEach(id => {
      $(id).addEventListener("input", updateButtons);
    });
  };

  // =============================================================
  // åˆå§‹åŒ–å…¥å£
  // =============================================================
  // æ‰§è¡Œé¡ºåºï¼š
  //   1. å¡«å…… UI
  //   2. æ‰“å¼€ IndexedDB
  //   3. ç»‘å®šäº‹ä»¶
  //   4. æ˜¾ç¤ºè§£é”ç•Œé¢
  //
  // è‹¥æ­¤å¤„æŠ¥é”™ï¼Œè¯´æ˜æµè§ˆå™¨ç¯å¢ƒä¸æ”¯æŒ IndexedDB æˆ– WebCryptoã€‚
  // ---------------------------
  // Init
  // ---------------------------
  const init = async () => {
    fillTypeSelects();
    db = await openDB();
    bindEvents();

    // UX: adjust search placeholder (no notes search unless you implement extra toggle)
    $("search").placeholder = "æœç´¢ï¼šæ ‡é¢˜ / è´¦å· / URL / æ ‡ç­¾ / ç±»å‹ / ç»‘å®šä¿¡æ¯ / ä¼šå‘˜ä¿¡æ¯ï¼ˆä¸å«å¤‡æ³¨ï¼‰";

    await showModal();
    renderList();
    updateButtons();
    updateSessionPill();

    // Default hide
    hideSecret();
  };

  init().catch(err => {
    console.error(err);
    alert("åˆå§‹åŒ–å¤±è´¥ï¼š" + (err?.message || err));
  });
})();
</script>
</body>
</html>
